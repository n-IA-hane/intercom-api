# ==============================================================================
# ESP32-S3 INTERCOM MINI - New TCP-based API
# ==============================================================================
#
# Uses the new intercom_api component with TCP streaming on port 6054.
# Replaces UDP-based intercom_audio with a more reliable TCP approach.
#
# HARDWARE:
#   - Board: ESP32-S3 Mini (4MB Flash, Quad PSRAM)
#   - Microphone: SPH0645 I2S MEMS (I2S_NUM_0) - has DC offset
#   - Speaker: MAX98357A I2S amplifier (I2S_NUM_1)
#   - LED: WS2812 RGB (GPIO21)
#
# GPIO PINOUT:
#   Microphone (SPH0645):
#     - WS/LRCLK: GPIO3
#     - SCK/BCLK: GPIO2
#     - SD/DIN:   GPIO4
#
#   Speaker (MAX98357A):
#     - LRC/LRCLK: GPIO6
#     - BCLK:      GPIO7
#     - DIN:       GPIO8
#
#   LED (WS2812):
#     - DATA: GPIO21
#
# ==============================================================================

substitutions:
  name: intercom-mini
  friendly_name: Intercom Mini
  ringing_timeout: "30s"  # Timeout for unanswered calls

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // Restore speaker volume from saved state
          float vol = id(speaker_volume).state / 100.0f;
          id(intercom).set_volume(vol);
          // Restore mic gain from saved state (dB)
          id(intercom).set_mic_gain_db(id(mic_gain).state);
          // Initialize contacts with Home Assistant as default
          if (id(contacts).empty()) {
            id(contacts).push_back("Home Assistant");
            id(peer_name) = "Home Assistant";
          }

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"

psram:
  mode: quad
  speed: 80MHz

# ==============================================================================
# CONNECTIVITY
# ==============================================================================
api:

ota:
  - platform: esphome

logger:
  hardware_uart: UART0
  level: INFO
  logs:
    intercom_api: INFO
    component: INFO

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: 192.168.1.18
  ap:
    ssid: "${name} Fallback"

# ==============================================================================
# EXTERNAL COMPONENTS
# ==============================================================================
external_components:
  - source:
      type: local
      path: esphome_components
    components: [intercom_api, esp_aec]

# ==============================================================================
# I2S AUDIO BUSES
# ==============================================================================
i2s_audio:
  # I2S Bus 0: SPH0645 Microphone
  - id: i2s_mic_bus
    i2s_lrclk_pin: GPIO3
    i2s_bclk_pin: GPIO2

  # I2S Bus 1: MAX98357A Speaker
  - id: i2s_spk_bus
    i2s_lrclk_pin: GPIO6
    i2s_bclk_pin: GPIO7

# ==============================================================================
# MICROPHONE (SPH0645)
# ==============================================================================
microphone:
  - platform: i2s_audio
    id: mic_component
    i2s_audio_id: i2s_mic_bus
    i2s_din_pin: GPIO4
    adc_type: external
    pdm: false
    bits_per_sample: 32bit
    sample_rate: 16000
    channel: left

# ==============================================================================
# SPEAKER (MAX98357A)
# ==============================================================================
speaker:
  - platform: i2s_audio
    id: spk_component
    i2s_audio_id: i2s_spk_bus
    i2s_dout_pin: GPIO8
    dac_type: external
    i2s_mode: primary
    sample_rate: 16000
    bits_per_sample: 16bit
    timeout: never
    buffer_duration: 100ms  # ~6 chunks buffer - low latency without underrun

# ==============================================================================
# AEC (Acoustic Echo Cancellation) - ESP-SR
# ==============================================================================
esp_aec:
  id: aec_processor
  sample_rate: 16000
  filter_length: 4          # 4 recommended for ESP32-S3
  mode: voip_low_cost       # Best for voice intercom

# ==============================================================================
# INTERCOM API (TCP-based, port 6054)
# ==============================================================================
intercom_api:
  id: intercom
  microphone: mic_component
  speaker: spk_component
  mic_bits: 32              # SPH0645 is 32-bit I2S mic
  dc_offset_removal: true   # Required for SPH0645 (has DC bias)
  aec_id: aec_processor     # Link to AEC component

# ==============================================================================
# GLOBALS
# ==============================================================================
globals:
  - id: peer_name
    type: std::string
    restore_value: no
    initial_value: '"Home Assistant"'

  - id: contacts
    type: std::vector<std::string>
    restore_value: no

  - id: contact_index
    type: int
    restore_value: yes
    initial_value: '0'

# ==============================================================================
# SCRIPTS
# ==============================================================================
script:
  # Ringing timeout - returns to Idle if no one answers
  - id: ringing_timeout_script
    mode: restart  # Restart if called again (resets timer)
    then:
      - logger.log: "Ringing timeout started (${ringing_timeout})"
      - delay: ${ringing_timeout}
      - lambda: |-
          std::string state = id(intercom_state).state;
          if (state == "Ringing" || state == "Calling") {
            ESP_LOGI("intercom", "Ringing timeout - returning to Idle");
            id(intercom).stop();
            id(peer_name) = "Home Assistant";
          }

  # Cancel ringing timeout (called when call is answered)
  - id: stop_ringing_timeout
    then:
      - script.stop: ringing_timeout_script
      - logger.log: "Ringing timeout cancelled"

  # Cycle to next contact
  - id: next_contact
    then:
      - lambda: |-
          if (id(contacts).empty()) {
            ESP_LOGW("intercom", "No contacts available");
            return;
          }
          id(contact_index) = (id(contact_index) + 1) % id(contacts).size();
          id(peer_name) = id(contacts)[id(contact_index)];
          ESP_LOGI("intercom", "Selected contact: %s", id(peer_name).c_str());
      - component.update: destination_sensor

  # Cycle to previous contact
  - id: previous_contact
    then:
      - lambda: |-
          if (id(contacts).empty()) {
            ESP_LOGW("intercom", "No contacts available");
            return;
          }
          int size = id(contacts).size();
          id(contact_index) = (id(contact_index) - 1 + size) % size;
          id(peer_name) = id(contacts)[id(contact_index)];
          ESP_LOGI("intercom", "Selected contact: %s", id(peer_name).c_str());
      - component.update: destination_sensor

# ==============================================================================
# VOLUME & GAIN CONTROL
# ==============================================================================
number:
  - platform: template
    id: speaker_volume
    name: "Speaker Volume"
    icon: "mdi:volume-high"
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 80
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    set_action:
      - lambda: |-
          float vol = x / 100.0f;
          id(intercom).set_volume(vol);

  - platform: template
    id: mic_gain
    name: "Mic Gain"
    icon: "mdi:microphone"
    min_value: -20
    max_value: 20
    step: 1
    initial_value: 0
    optimistic: true
    restore_value: true
    unit_of_measurement: "dB"
    set_action:
      - lambda: |-
          id(intercom).set_mic_gain_db(x);

# ==============================================================================
# SWITCHES
# ==============================================================================
switch:
  - platform: template
    id: aec_switch
    name: "Echo Cancellation"
    icon: "mdi:ear-hearing"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: 'id(intercom).set_aec_enabled(true);'
    turn_off_action:
      - lambda: 'id(intercom).set_aec_enabled(false);'

  - platform: template
    id: auto_answer_switch
    name: "Auto Answer"
    icon: "mdi:phone-incoming"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: 'id(intercom).set_auto_answer(true);'
    turn_off_action:
      - lambda: 'id(intercom).set_auto_answer(false);'

# ==============================================================================
# STATUS LED (WS2812 RGB on GPIO21)
# ==============================================================================
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    icon: "mdi:led-on"
    pin: GPIO21
    chipset: WS2812
    num_leds: 1
    rgb_order: RGB
    effects:
      - pulse:
          name: "Streaming"
          min_brightness: 20%
          max_brightness: 100%
      - strobe:
          name: "Ringing"
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 250ms
            - state: false
              duration: 250ms

# ==============================================================================
# TEXT SENSORS (status)
# ==============================================================================
text_sensor:
  - platform: intercom_api
    id: intercom_state
    name: "Intercom State"
    intercom_api_id: intercom
    on_value:
      then:
        - if:
            condition:
              text_sensor.state:
                id: intercom_state
                state: "Ringing"
            then:
              - light.turn_on:
                  id: status_led
                  effect: "Ringing"
                  red: 100%
                  green: 0%
                  blue: 0%
              - script.execute: ringing_timeout_script
        - if:
            condition:
              text_sensor.state:
                id: intercom_state
                state: "Calling"
            then:
              - script.execute: ringing_timeout_script
        - if:
            condition:
              text_sensor.state:
                id: intercom_state
                state: "Streaming"
            then:
              - light.turn_on:
                  id: status_led
                  effect: "None"
                  red: 0%
                  green: 100%
                  blue: 0%
              - script.execute: stop_ringing_timeout
        - if:
            condition:
              text_sensor.state:
                id: intercom_state
                state: "Idle"
            then:
              - light.turn_off:
                  id: status_led
              - script.execute: stop_ringing_timeout
              - lambda: 'id(peer_name) = "Home Assistant";'

  # Currently selected destination (from contacts array)
  - platform: template
    id: destination_sensor
    name: "Destination"
    icon: "mdi:phone-forward"
    update_interval: never
    lambda: |-
      if (id(contacts).empty()) return std::string("Home Assistant");
      int idx = id(contact_index) % id(contacts).size();
      return id(contacts)[idx];

# ==============================================================================
# DIAGNOSTICS
# ==============================================================================
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    update_interval: 60s

  - platform: uptime
    name: "Uptime"
    update_interval: 60s

  - platform: internal_temperature
    name: "CPU Temperature"
    update_interval: 60s

button:
  # Call/Answer/Hangup button (P2P mode - calls Home Assistant)
  - platform: template
    id: call_button
    name: "Call"
    icon: "mdi:phone"
    on_press:
      - lambda: |-
          std::string state = id(intercom_state).state;

          // If ringing (incoming call), answer it
          if (state == "Ringing") {
            id(intercom).answer_call();
            return;
          }

          // If in call or streaming, hang up
          if (state == "Streaming" || state == "Calling") {
            id(intercom).stop();
            return;
          }

          // IDLE: Start call to Home Assistant
          id(intercom).start();

  - platform: template
    id: previous_contact_button
    name: "Previous Contact"
    icon: "mdi:account-arrow-left"
    on_press:
      - script.execute: previous_contact

  - platform: template
    id: next_contact_button
    name: "Next Contact"
    icon: "mdi:account-arrow-right"
    on_press:
      - script.execute: next_contact

  - platform: restart
    name: "Restart"
    icon: "mdi:restart"

# ==============================================================================
# CONTACTS & CALLER INFO (received from HA)
# ==============================================================================
text:
  - platform: template
    id: incoming_caller
    name: "Incoming Caller"
    mode: text
    entity_category: config
    optimistic: true
    on_value:
      then:
        - lambda: |-
            // Set by HA when someone is calling this device
            if (!x.empty()) {
              id(peer_name) = x;
              ESP_LOGI("intercom", "Incoming call from: %s", x.c_str());
            }

  - platform: template
    id: contacts_data
    name: "Contacts"
    mode: text
    entity_category: config
    optimistic: true
    on_value:
      then:
        - lambda: |-
            // Parse contacts from HA: "Home Assistant,Cucina,Camera"
            id(contacts).clear();
            std::string data = x;
            if (data.empty()) {
              id(contacts).push_back("Home Assistant");
            } else {
              size_t pos;
              while (!data.empty()) {
                pos = data.find(',');
                std::string name = (pos != std::string::npos) ? data.substr(0, pos) : data;
                if (!name.empty()) {
                  id(contacts).push_back(name);
                }
                if (pos == std::string::npos) break;
                data.erase(0, pos + 1);
              }
            }
            // Reset to first contact and update display
            id(contact_index) = 0;
            if (!id(contacts).empty()) {
              id(peer_name) = id(contacts)[0];
            }
            id(destination_sensor).update();
            ESP_LOGI("intercom", "Loaded %d contacts", id(contacts).size());
